function isNumber(t){return"number"===typeof t}function isString(t){return"string"===typeof t}function isBoolean(t){return"boolean"===typeof t}function isObject(t){return"[object Object]"===Object.prototype.toString.call(t)}function mathAbs(t){return Math.abs(t)}function mathSign(t){return Math.sign(t)}function deltaAbs(t,n){return mathAbs(t-n)}function factorAbs(t,n){if(0===t||0===n)return 0;if(mathAbs(t)<=mathAbs(n))return 0;const e=deltaAbs(mathAbs(t),mathAbs(n));return mathAbs(e/t)}function arrayKeys(t){return objectKeys(t).map(Number)}function arrayLast(t){return t[arrayLastIndex(t)]}function arrayLastIndex(t){return Math.max(0,t.length-1)}function objectKeys(t){return Object.keys(t)}function objectsMergeDeep(t,n){return[t,n].reduce(((t,n)=>{objectKeys(n).forEach((e=>{const o=t[e];const r=n[e];const s=isObject(o)&&isObject(r);t[e]=s?objectsMergeDeep(o,r):r}));return t}),{})}function isMouseEvent(t,n){return"undefined"!==typeof n.MouseEvent&&t instanceof n.MouseEvent}function Alignment(t,n){const e={start:start,center:center,end:end};function start(){return 0}function center(t){return end(t)/2}function end(t){return n-t}function percent(){return n*Number(t)}function measure(n){return isNumber(t)?percent():e[t](n)}const o={measure:measure};return o}function Axis(t,n){const e="y"===t?"y":"x";const o="y"===t?"x":"y";const r=getStartEdge();const s=getEndEdge();function measureSize(t){const{width:n,height:o}=t;return"x"===e?n:o}function getStartEdge(){return"y"===e?"top":"rtl"===n?"right":"left"}function getEndEdge(){return"y"===e?"bottom":"rtl"===n?"left":"right"}const i={scroll:e,cross:o,startEdge:r,endEdge:s,measureSize:measureSize};return i}function Limit(t,n){const e=mathAbs(t-n);function reachedMin(n){return n<t}function reachedMax(t){return t>n}function reachedAny(t){return reachedMin(t)||reachedMax(t)}function constrain(e){return reachedAny(e)?reachedMin(e)?t:n:e}function removeOffset(t){return e?t-e*Math.ceil((t-n)/e):t}const o={length:e,max:n,min:t,constrain:constrain,reachedAny:reachedAny,reachedMax:reachedMax,reachedMin:reachedMin,removeOffset:removeOffset};return o}function Counter(t,n,e){const{constrain:o}=Limit(0,t);const r=t+1;let s=withinLimit(n);function withinLimit(t){return e?mathAbs((r+t)%r):o(t)}function get(){return s}function set(t){s=withinLimit(t);return i}function add(t){return clone().set(get()+t)}function clone(){return Counter(t,get(),e)}const i={get:get,set:set,add:add,clone:clone};return i}function Direction(t){const n="rtl"===t?-1:1;function apply(t){return t*n}const e={apply:apply};return e}function EventStore(){let t=[];function add(e,o,r,s={passive:true}){e.addEventListener(o,r,s);t.push((()=>e.removeEventListener(o,r,s)));return n}function clear(){t=t.filter((t=>t()))}const n={add:add,clear:clear};return n}function DragHandler(t,n,e,o,r,s,i,c,a,u,l,d,f,p,m,g,S,h,b){const{cross:v}=t;const A=["INPUT","SELECT","TEXTAREA"];const L={passive:false};const w=EventStore();const E=EventStore();const D=Limit(50,225).constrain(m.measure(20));const T={mouse:300,touch:400};const P={mouse:500,touch:600};const I=g?43:25;let M=false;let z=0;let B=0;let O=false;let N=false;let C=false;let k=false;function init(t,n){if(!n)return;function downIfAllowed(e){(isBoolean(n)||n(t,e))&&down(e)}const o=e;w.add(o,"dragstart",(t=>t.preventDefault()),L).add(o,"touchmove",(()=>{}),L).add(o,"touchend",(()=>{})).add(o,"touchstart",downIfAllowed).add(o,"mousedown",downIfAllowed).add(o,"touchcancel",up).add(o,"contextmenu",up).add(o,"click",click,true)}function destroy(){w.clear();E.clear()}function addDragEvents(){const t=k?o:e;E.add(t,"touchmove",move,L).add(t,"touchend",up).add(t,"mousemove",move,L).add(t,"mouseup",up)}function isFocusNode(t){const n=t.nodeName||"";return A.includes(n)}function forceBoost(){const t=g?P:T;const n=k?"mouse":"touch";return t[n]}function allowedForce(t,n){const e=f.add(-1*mathSign(t));const o=d.byDistance(t,!g).distance;return g||mathAbs(t)<D?o:h&&n?.5*o:d.byIndex(e.get(),0).distance}function down(t){const n=isMouseEvent(t,r);k=n;if((!n||0===t.button)&&!isFocusNode(t.target)){C=g&&n&&!t.buttons&&M;M=deltaAbs(s.get(),c.get())>=2;O=true;i.pointerDown(t);l.useFriction(0).useDuration(0);s.set(c);addDragEvents();z=i.readPoint(t);B=i.readPoint(t,v);p.emit("pointerDown")}}function move(t){const e=i.readPoint(t);const o=i.readPoint(t,v);const r=deltaAbs(e,z);const c=deltaAbs(o,B);if(!N&&!k){if(!t.cancelable)return up(t);N=r>c;if(!N)return up(t)}const u=i.pointerMove(t);r>S&&(C=true);l.useFriction(.3).useDuration(1);a.start();s.add(n.apply(u));t.preventDefault()}function up(t){const e=d.byDistance(0,false);const o=e.index!==f.get();const r=i.pointerUp(t)*forceBoost();const s=allowedForce(n.apply(r),o);const c=factorAbs(r,s);const a=I-10*c;const m=b+c/50;N=false;O=false;E.clear();l.useDuration(a).useFriction(m);u.distance(s,!g);k=false;p.emit("pointerUp")}function click(t){if(C){t.stopPropagation();t.preventDefault()}}function pointerDown(){return O}const H={init:init,pointerDown:pointerDown,destroy:destroy};return H}function DragTracker(t,n){const e=170;let o;let r;function readTime(t){return t.timeStamp}function readPoint(e,o){const r=o||t.scroll;const s="client"+("x"===r?"X":"Y");return(isMouseEvent(e,n)?e:e.touches[0])[s]}function pointerDown(t){o=t;r=t;return readPoint(t)}function pointerMove(t){const n=readPoint(t)-readPoint(r);const s=readTime(t)-readTime(o)>e;r=t;s&&(o=t);return n}function pointerUp(t){if(!o||!r)return 0;const n=readPoint(r)-readPoint(o);const s=readTime(t)-readTime(o);const i=readTime(t)-readTime(r)>e;const c=n/s;const a=s&&!i&&mathAbs(c)>.1;return a?c:0}const s={pointerDown:pointerDown,pointerMove:pointerMove,pointerUp:pointerUp,readPoint:readPoint};return s}function PercentOfView(t){function measure(n){return t*(n/100)}const n={measure:measure};return n}function ResizeHandler(t,n,e,o){let r;let s;let i=[];let c=false;function readSize(t){return e.measureSize(t.getBoundingClientRect())}function init(e,a){if(!a)return;s=readSize(t);i=n.map(readSize);function defaultCallback(r){for(const c of r){const r=c.target===t;const a=n.indexOf(c.target);const u=r?s:i[a];const l=readSize(r?t:n[a]);if(u!==l){e.reInit();o.emit("resize");break}}}r=new ResizeObserver((t=>{c||(isBoolean(a)||a(e,t))&&defaultCallback(t)}));const u=[t].concat(n);u.forEach((t=>r.observe(t)))}function destroy(){r&&r.disconnect();c=true}const a={init:init,destroy:destroy};return a}function ScrollBody(t,n,e,o){let r=true;let s=0;let i=0;let c=e;let a=o;function seek(){const e=n.get()-t.get();const o=!a||!c;if(o){s=0;t.set(n)}else{s+=e/c;s*=a;t.add(s)}i=mathSign(s||e);r=mathAbs(e)<.001;return u}function settled(){r&&t.set(n);return r}function velocity(){return s}function direction(){return i}function useBaseDuration(){return useDuration(e)}function useBaseFriction(){return useFriction(o)}function useDuration(t){c=t;return u}function useFriction(t){a=t;return u}const u={direction:direction,seek:seek,settled:settled,useBaseFriction:useBaseFriction,useBaseDuration:useBaseDuration,useFriction:useFriction,useDuration:useDuration,velocity:velocity};return u}function ScrollBounds(t,n,e,o,r){const s=r.measure(10);const i=r.measure(50);const c=Limit(.1,.99);let a=false;function shouldConstrain(){return!a&&(!!t.reachedAny(e.get())&&!!t.reachedAny(n.get()))}function constrain(r){if(!shouldConstrain())return;const a=t.reachedMin(n.get())?"min":"max";const u=mathAbs(t[a]-n.get());const l=e.get()-n.get();const d=c.constrain(u/i);e.subtract(l*d);if(!r&&mathAbs(l)<s){e.set(t.constrain(e.get()));o.useDuration(25).useBaseFriction()}}function toggleActive(t){a=!t}const u={constrain:constrain,toggleActive:toggleActive};return u}function ScrollContain(t,n,e,o){const r=Limit(-n+t,e[0]);const s=measureBounded();const i=measureContained();function findDuplicates(){const t=s[0];const n=arrayLast(s);const e=s.lastIndexOf(t);const o=s.indexOf(n)+1;return Limit(e,o)}function measureBounded(){return e.map(r.constrain).map((t=>parseFloat(t.toFixed(3))))}function measureContained(){if(n<=t)return[r.max];if("keepSnaps"===o)return s;const{min:e,max:i}=findDuplicates();return s.slice(e,i)}const c={snapsContained:i};return c}function ScrollLimit(t,n,e){const o=n[0];const r=e?o-t:arrayLast(n);const s=Limit(r,o);const i={limit:s};return i}function ScrollLooper(t,n,e,o){const r=.1;const s=n.min+r;const i=n.max+r;const{reachedMin:c,reachedMax:a}=Limit(s,i);function shouldLoop(t){return 1===t?a(e.get()):-1===t&&c(e.get())}function loop(n){if(!shouldLoop(n))return;const e=t*(-1*n);o.forEach((t=>t.add(e)))}const u={loop:loop};return u}function ScrollProgress(t){const{max:n,length:e}=t;function get(t){const o=t-n;return o/-e}const o={get:get};return o}function ScrollSnaps(t,n,e,o,r,s,i){const{startEdge:c,endEdge:a}=t;const{groupSlides:u}=s;const l=measureSizes().map(n.measure);const d=measureUnaligned();const f=measureAligned();function measureSizes(){return u(o).map((t=>arrayLast(t)[a]-t[0][c])).map(mathAbs)}function measureUnaligned(){return o.map((t=>e[c]-t[c])).map((t=>-mathAbs(t)))}function measureAligned(){const t=0;const n=arrayLast(d)-arrayLast(r);return u(d).map((t=>t[0])).map(((e,o,r)=>{const s=!o;const c=o===arrayLastIndex(r);return i&&s?t:i&&c?n:e+l[o]}))}const p={snaps:d,snapsAligned:f};return p}function ScrollTarget(t,n,e,o,r){const{reachedAny:s,removeOffset:i,constrain:c}=o;function minDistance(t){return t.concat().sort(((t,n)=>mathAbs(t)-mathAbs(n)))[0]}function findTargetSnap(e){const o=t?i(e):c(e);const r=n.map((t=>t-o)).map((t=>shortcut(t,0))).map(((t,n)=>({diff:t,index:n}))).sort(((t,n)=>mathAbs(t.diff)-mathAbs(n.diff)));const{index:s}=r[0];return{index:s,distance:o}}function shortcut(n,o){const r=[n,n+e,n-e];if(!t)return r[0];if(!o)return minDistance(r);const s=r.filter((t=>mathSign(t)===o));return minDistance(s)}function byIndex(t,e){const o=n[t]-r.get();const s=shortcut(o,e);return{index:t,distance:s}}function byDistance(e,o){const i=r.get()+e;const{index:c,distance:a}=findTargetSnap(i);const u=!t&&s(i);if(!o||u)return{index:c,distance:e};const l=n[c]-a;const d=e+shortcut(l,0);return{index:c,distance:d}}const a={byDistance:byDistance,byIndex:byIndex,shortcut:shortcut};return a}function ScrollTo(t,n,e,o,r,s){function scrollTo(o){const i=o.distance;const c=o.index!==n.get();if(i){t.start();r.add(i)}if(c){e.set(n.get());n.set(o.index);s.emit("select")}}function distance(t,n){const e=o.byDistance(t,n);scrollTo(e)}function index(t,e){const r=n.clone().set(t);const s=o.byIndex(r.get(),e);scrollTo(s)}const i={distance:distance,index:index};return i}function Vector1D(t){let n=t;function get(){return n}function set(t){n=normalizeInput(t)}function add(t){n+=normalizeInput(t)}function subtract(t){n-=normalizeInput(t)}function normalizeInput(t){return isNumber(t)?t:t.get()}const e={get:get,set:set,add:add,subtract:subtract};return e}function Translate(t,n,e){const o="x"===t.scroll?x:y;const r=e.style;let s=false;function x(t){return`translate3d(${t}px,0px,0px)`}function y(t){return`translate3d(0px,${t}px,0px)`}function to(t){s||(r.transform=o(n.apply(t)))}function toggleActive(t){s=!t}function clear(){if(!s){r.transform="";e.getAttribute("style")||e.removeAttribute("style")}}const i={clear:clear,to:to,toggleActive:toggleActive};return i}function SlideLooper(t,n,e,o,r,s,i,c,a){const u=arrayKeys(r);const l=arrayKeys(r).reverse();const d=startPoints().concat(endPoints());function removeSlideSizes(t,n){return t.reduce(((t,n)=>t-r[n]),n)}function slidesInGap(t,n){return t.reduce(((t,e)=>{const o=removeSlideSizes(t,n);return o>0?t.concat([e]):t}),[])}function findLoopPoints(e,r){const s="start"===r;const u=s?-o:o;const l=i.findSlideBounds([u]);return e.map((e=>{const r=s?0:-o;const i=s?o:0;const u=l.filter((t=>t.index===e))[0];const d=u[s?"end":"start"];const f=Vector1D(-1);const p=Translate(t,n,a[e]);const target=()=>c.get()>d?r:i;return{index:e,location:f,translate:p,target:target}}))}function startPoints(){const t=s[0]-1;const n=slidesInGap(l,t);return findLoopPoints(n,"end")}function endPoints(){const t=e-s[0]-1;const n=slidesInGap(u,t);return findLoopPoints(n,"start")}function canLoop(){return d.every((({index:t})=>{const n=u.filter((n=>n!==t));return removeSlideSizes(n,e)<=.1}))}function loop(){d.forEach((t=>{const{target:n,translate:e,location:o}=t;const r=n();if(r!==o.get()){e.to(r);o.set(r)}}))}function clear(){d.forEach((t=>t.translate.clear()))}const f={canLoop:canLoop,clear:clear,loop:loop,loopPoints:d};return f}function SlidesHandler(t,n){let e;let o=false;function init(r,s){if(s){e=new MutationObserver((t=>{o||(isBoolean(s)||s(r,t))&&defaultCallback(t)}));e.observe(t,{childList:true})}function defaultCallback(t){for(const e of t)if("childList"===e.type){r.reInit();n.emit("slidesChanged");break}}}function destroy(){e&&e.disconnect();o=true}const r={init:init,destroy:destroy};return r}function SlidesInView(t,n,e,o,r,s,i){const{removeOffset:c,constrain:a}=r;const u=.5;const l=s?[0,n,-n]:[0];const d=findSlideBounds(l,i);function findSlideThresholds(t){const n=t||0;return e.map((t=>{const e=Limit(u,t-u);return e.constrain(t*n)}))}function findSlideBounds(n,r){const s=n||l;const i=findSlideThresholds(r);return s.reduce(((n,r)=>{const s=o.map(((n,o)=>({start:n-e[o]+i[o]+r,end:n+t-i[o]+r,index:o})));return n.concat(s)}),[])}function check(t,n){const e=s?c(t):a(t);const o=n||d;return o.reduce(((t,n)=>{const{index:o,start:r,end:s}=n;const i=t.includes(o);const c=r<e&&s>e;return!i&&c?t.concat([o]):t}),[])}const f={check:check,findSlideBounds:findSlideBounds};return f}function SlideSizes(t,n,e,o,r,s){const{measureSize:i,startEdge:c,endEdge:a}=t;const u=e[0]&&r;const l=measureStartGap();const d=measureEndGap();const f=e.map(i);const p=measureWithGaps();function measureStartGap(){if(!u)return 0;const t=e[0];return mathAbs(n[c]-t[c])}function measureEndGap(){if(!u)return 0;const t=s.getComputedStyle(arrayLast(o));return parseFloat(t.getPropertyValue(`margin-${a}`))}function measureWithGaps(){return e.map(((t,n,e)=>{const o=!n;const r=n===arrayLastIndex(e);return o?f[n]+l:r?f[n]+d:e[n+1][c]-t[c]})).map(mathAbs)}const m={slideSizes:f,slideSizesWithGaps:p};return m}function SlidesToScroll(t,n,e){const o=isNumber(e);function byNumber(t,n){return arrayKeys(t).filter((t=>t%n===0)).map((e=>t.slice(e,e+n)))}function bySize(e){return arrayKeys(e).reduce(((e,o)=>{const r=n.slice(arrayLast(e),o+1);const s=r.reduce(((t,n)=>t+n),0);return!o||s>t?e.concat(o):e}),[]).map(((t,n,o)=>e.slice(t,o[n+1])))}function groupSlides(t){return o?byNumber(t,e):bySize(t)}const r={groupSlides:groupSlides};return r}function Engine(t,n,e,o,r,s,i,c){const{align:a,axis:u,direction:l,startIndex:d,inViewThreshold:f,loop:p,duration:m,dragFree:g,dragThreshold:S,slidesToScroll:h,skipSnaps:b,containScroll:v}=s;const A=n.getBoundingClientRect();const L=e.map((t=>t.getBoundingClientRect()));const w=Direction(l);const E=Axis(u,l);const D=E.measureSize(A);const T=PercentOfView(D);const P=Alignment(a,D);const I=!p&&!!v;const M=p||!!v;const{slideSizes:z,slideSizesWithGaps:B}=SlideSizes(E,A,L,e,M,r);const O=SlidesToScroll(D,B,h);const{snaps:N,snapsAligned:C}=ScrollSnaps(E,P,A,L,B,O,I);const k=-arrayLast(N)+arrayLast(B);const{snapsContained:H}=ScrollContain(D,k,C,v);const F=I?H:C;const{limit:V}=ScrollLimit(k,F,p);const j=Counter(arrayLastIndex(F),d,p);const R=j.clone();const G=arrayKeys(e);const update=({dragHandler:t,scrollBody:n,scrollBounds:e,scrollLooper:o,slideLooper:r,eventHandler:s,animation:i,options:{loop:c}})=>{const a=t.pointerDown();c||e.constrain(a);const u=n.seek().settled();if(u&&!a){i.stop();s.emit("settle")}u||s.emit("scroll");if(c){o.loop(n.direction());r.loop()}};const render=({scrollBody:t,translate:n,location:e},o)=>{const r=t.velocity();const s=e.get()-r+r*o;n.to(s)};const K={update:()=>update(Z),render:t=>render(Z,t),start:()=>c.start(Z),stop:()=>c.stop(Z)};const U=.68;const W=F[j.get()];const q=Vector1D(W);const Q=Vector1D(W);const $=ScrollBody(q,Q,m,U);const X=ScrollTarget(p,F,k,V,Q);const Y=ScrollTo(K,j,R,X,Q,i);const J=SlidesInView(D,k,z,N,V,p,f);const Z={ownerDocument:o,ownerWindow:r,eventHandler:i,containerRect:A,slideRects:L,animation:K,axis:E,direction:w,dragHandler:DragHandler(E,w,t,o,r,Q,DragTracker(E,r),q,K,Y,$,X,j,i,T,g,S,b,U),eventStore:EventStore(),percentOfView:T,index:j,indexPrevious:R,limit:V,location:q,options:s,resizeHandler:ResizeHandler(n,e,E,i),scrollBody:$,scrollBounds:ScrollBounds(V,q,Q,$,T),scrollLooper:ScrollLooper(k,V,q,[q,Q]),scrollProgress:ScrollProgress(V),scrollSnaps:F,scrollTarget:X,scrollTo:Y,slideLooper:SlideLooper(E,w,D,k,B,F,J,q,e),slidesHandler:SlidesHandler(n,i),slidesInView:J,slideIndexes:G,slidesToScroll:O,target:Q,translate:Translate(E,w,n)};return Z}function Animations(t){const n=1e3/60;let e=[];let o=null;let r=0;let s=0;function animate(i){o||(o=i);const c=i-o;o=i;r+=c;while(r>=n){e.forEach((({animation:t})=>t.update()));r-=n}const a=mathAbs(r/n);e.forEach((({animation:t})=>t.render(a)));s&&t.requestAnimationFrame(animate)}function start(n){e.includes(n)||e.push(n);s||(s=t.requestAnimationFrame(animate))}function stop(n){e=e.filter((t=>t!==n));if(!e.length){t.cancelAnimationFrame(s);o=null;r=0;s=0}}function reset(){o=null;r=0}const i={start:start,stop:stop,reset:reset,window:t};return i}function EventHandler(){const t={};let n;function init(t){n=t}function getListeners(n){return t[n]||[]}function emit(t){getListeners(t).forEach((e=>e(n,t)));return e}function on(n,o){t[n]=getListeners(n).concat([o]);return e}function off(n,o){t[n]=getListeners(n).filter((t=>t!==o));return e}const e={init:init,emit:emit,off:off,on:on};return e}const t={align:"center",axis:"x",container:null,slides:null,containScroll:null,direction:"ltr",slidesToScroll:1,breakpoints:{},dragFree:false,dragThreshold:10,inViewThreshold:0,loop:false,skipSnaps:false,duration:25,startIndex:0,active:true,watchDrag:true,watchResize:true,watchSlides:true};function OptionsHandler(t){function mergeOptions(t,n){return objectsMergeDeep(t,n||{})}function optionsAtMedia(n){const e=n.breakpoints||{};const o=objectKeys(e).filter((n=>t.matchMedia(n).matches)).map((t=>e[t])).reduce(((t,n)=>mergeOptions(t,n)),{});return mergeOptions(n,o)}function optionsMediaQueries(n){return n.map((t=>objectKeys(t.breakpoints||{}))).reduce(((t,n)=>t.concat(n)),[]).map(t.matchMedia)}const n={mergeOptions:mergeOptions,optionsAtMedia:optionsAtMedia,optionsMediaQueries:optionsMediaQueries};return n}function PluginsHandler(t){let n=[];function init(e,o){n=e.filter((({options:n})=>false!==t.optionsAtMedia(n).active));n.forEach((n=>n.init(o,t)));return e.reduce(((t,n)=>Object.assign(t,{[n.name]:n})),{})}function destroy(){n=n.filter((t=>t.destroy()))}const e={init:init,destroy:destroy};return e}function EmblaCarousel(n,e,o){const r=n.ownerDocument;const s=r.defaultView;const i=OptionsHandler(s);const c=PluginsHandler(i);const a=EventStore();const u=EventStore();const l=EventHandler();const{animationRealms:d}=EmblaCarousel;const{mergeOptions:f,optionsAtMedia:p,optionsMediaQueries:m}=i;const{on:g,off:S,emit:h}=l;const b=reActivate;let v=false;let A;let L=f(t,EmblaCarousel.globalOptions);let w=f(L);let E=[];let D;let T;let P;function storeElements(){const{container:t,slides:e}=w;const o=isString(t)?n.querySelector(t):t;T=o||n.children[0];const r=isString(e)?T.querySelectorAll(e):e;P=[].slice.call(r||T.children)}function activate(t,e){if(v)return;const o=d.find((t=>t.window===s));const i=o||Animations(s);o||d.push(i);L=f(L,t);w=p(L);E=e||E;storeElements();A=Engine(n,T,P,r,s,w,l,i);m([L,...E.map((({options:t})=>t))]).forEach((t=>a.add(t,"change",reActivate)));if(w.active){A.translate.to(A.location.get());A.eventHandler.init(I);A.resizeHandler.init(I,w.watchResize);A.slidesHandler.init(I,w.watchSlides);u.add(r,"visibilitychange",(()=>{r.hidden&&i.reset()}));if(w.loop){if(!A.slideLooper.canLoop()){deActivate();activate({loop:false},e);L=f(L,{loop:true});return}A.slideLooper.loop()}T.offsetParent&&P.length&&A.dragHandler.init(I,w.watchDrag);D=c.init(E,I)}}function reActivate(t,n){const e=selectedScrollSnap();deActivate();activate(f({startIndex:e},t),n);l.emit("reInit")}function deActivate(){A.dragHandler.destroy();A.animation.stop();A.eventStore.clear();A.translate.clear();A.slideLooper.clear();A.resizeHandler.destroy();A.slidesHandler.destroy();c.destroy();a.clear();u.clear()}function destroy(){if(!v){v=true;a.clear();deActivate();l.emit("destroy")}}function slidesInView(t){const n=A[t?"target":"location"].get();const e=w.loop?"removeOffset":"constrain";return A.slidesInView.check(A.limit[e](n))}function slidesNotInView(t){const n=slidesInView(t);return A.slideIndexes.filter((t=>!n.includes(t)))}function scrollTo(t,n,e){if(w.active&&!v){A.scrollBody.useBaseFriction().useDuration(n?0:w.duration);A.scrollTo.index(t,e||0)}}function scrollNext(t){const n=A.index.add(1).get();scrollTo(n,true===t,-1)}function scrollPrev(t){const n=A.index.add(-1).get();scrollTo(n,true===t,1)}function canScrollNext(){const t=A.index.add(1).get();return t!==selectedScrollSnap()}function canScrollPrev(){const t=A.index.add(-1).get();return t!==selectedScrollSnap()}function scrollSnapList(){return A.scrollSnaps.map(A.scrollProgress.get)}function scrollProgress(){return A.scrollProgress.get(A.location.get())}function selectedScrollSnap(){return A.index.get()}function previousScrollSnap(){return A.indexPrevious.get()}function plugins(){return D}function internalEngine(){return A}function rootNode(){return n}function containerNode(){return T}function slideNodes(){return P}const I={canScrollNext:canScrollNext,canScrollPrev:canScrollPrev,containerNode:containerNode,internalEngine:internalEngine,destroy:destroy,off:S,on:g,emit:h,plugins:plugins,previousScrollSnap:previousScrollSnap,reInit:b,rootNode:rootNode,scrollNext:scrollNext,scrollPrev:scrollPrev,scrollProgress:scrollProgress,scrollSnapList:scrollSnapList,scrollTo:scrollTo,selectedScrollSnap:selectedScrollSnap,slideNodes:slideNodes,slidesInView:slidesInView,slidesNotInView:slidesNotInView};activate(e,o);setTimeout((()=>l.emit("init")),0);return I}EmblaCarousel.animationRealms=[];EmblaCarousel.globalOptions=void 0;export{EmblaCarousel as default};

